Scope
=====

.. warning:: |write-up|

This library is narrow in purpose. In order to best manage expectations we outline which things are within scope and
provided, which are within scope but left for future work, and finally what is out of scope.

Current features
----------------

- :doc:`concepts` for ranges and their positions
- common but simple enough :doc:`source ranges <sources>`
- core composite ranges (`map`, `filter`, `zip`, `flatten`, `concat`)
- some additional composite ranges (available as :doc:`transformations`, :doc:`compositions`, or :doc:`arrangements`)
- simple range consumption patterns (`loop`, :ref:`collects`, :ref:`folds`)
- a last resort adapter for iterator-based code: `as_iterators`

Possible future work
--------------------

- Give up on `Saveable` ranges, which make a lot of things more complicated just to support a handful of cases (only
  `generate` ranges so far). Similarly finding a better solution than `container` would open the way to giving up on
  rooted ranges, the other exceptional situation. Eventually this would mean getting rid of `Range` altogether, leaving
  just `bounded_range`.
- `concat` and `flatten` **must** be usable
- Tailored composite range capabilities. (This may be connected to the previous item.)
- More work on the connection between 'eager' algorithms as range consumers and 'lazy'/on-demand online algorithms as
  composite ranges (e.g. in-place sort vs online sort).
- More elaborate source ranges.
- More :doc:`consumers` (e.g. algorithms).
- A solid vocabulary of composite ranges to cover enough ground in several areas, e.g.:

  * typical variadic composition patterns (e.g. round-robin)
  * typical but non-fundamental composite patterns, e.g. moved/decayed, enumerate
  * intersperse/join
- An IEnumerable (or begin/end) equivalent for things that are not necessarily ranges themselves, but come with an
  associated range. A lot of code that is currently written against `Range` (including the composite ranges and
  algorithms) should really be written against this putative concept. E.g. `flatten` already does this to an extent, see
  `AsRange`.
- Known-finite ranges (algorithms should be found first).

Out of scope
------------

- most things having to do with :ref:`internal iteration <external-iteration>`, e.g. await/yield (but see `coro`)
- an equivalent to the notion of output iterator, which should be unnecessary: ranges are meant to be used with
  :doc:`consumers`
- containers (although `as_range` and `container` serve to construct a view into a container or to adapt a container)
- clever syntax (operators, member functions), at least for now

The great big bikeshed
----------------------

In vague descending order of importance:

- terminology and include layout for sources, composites (transformations/compositions/arrangements), consumers, etc.
- naming convention for composite ranges: e.g. is `reverse(arg) <reverse>` appropriate even though it creates a separate
  range without modifying its argument? any answer would also apply to well-known quantities such as `map`
- `group`:

  * what to call the `group` elements: *groupings*, *runs*, *groups*
  * what to call the first argument of `group`: a key function, a projection function
  * whether `group` elements should carry their computed criterion around
- whether `integers\<Num\> <integers>` and `ints` should be function-like constants, or constant ranges
