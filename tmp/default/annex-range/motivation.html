<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Motivation &#8212; annex-range 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="annex-range 0.1.0 documentation" href="index.html" />
    <link rel="next" title="Scope" href="scope.html" />
    <link rel="prev" title="Quickstart" href="quickstart.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="scope.html" title="Scope"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="Quickstart"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">annex-range 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="motivation">
<h1>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h1>
<p>Self-contained range abstractions are a staple feature of programming languages as seen with <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#typeiter">Python iterators</a>, <a class="reference external" href="https://dlang.org/phobos/std_range.html">D
ranges</a>, <a class="reference external" href="https://doc.rust-lang.org/std/iter/index.html">Rust iterators</a>, or <a class="reference external" href="https://msdn.microsoft.com/en-us/library/78dfe2yb%28v=vs.110%29.aspx">C# enumerators</a>. In C++ however the closest analogue concepts of <a class="reference external" href="http://en.cppreference.com/w/cpp/concept/Iterator">iterators</a> have
been found wanting at times.</p>
<p>This library is a tabula rasa approach at the problems that range abstractions aim to solve, with the double goal of
producing a defense of position-based ranges as well as a practically-minded API.</p>
<div class="section" id="iteration">
<h2>Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h2>
<p>The problem that range abstractions tackle is that of iteration over a given notional and abstract sequence. &#8216;Notional
and abstract&#8217; means that the sequence need not explicitly and concretely live inside the program, as in the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// iterate over 0, 1, 2, 3, 4</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// use i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above the abstract sequence of numbers from 0 to 5 exclusive doesn&#8217;t exist e.g. as numbers in memory, but is
instead implicitly encoded in the program structure and control flow (namely the <code class="docutils literal"><span class="pre">for</span></code> loop and its <em>i</em> variable).</p>
<p>Practical range abstractions aim to make it possible and convenient to represent, compose, and consume such sequences.</p>
<div class="section" id="internal-and-external-iteration">
<span id="external-iteration"></span><h3>Internal and external iteration<a class="headerlink" href="#internal-and-external-iteration" title="Permalink to this headline">¶</a></h3>
<p>There is a distinction to be made between so-called internal and external iteration. This is an interesting topic in
itself but to keep things short it suffices to say that this library concerns itself with external iteration. This is
the same as existing C++ iterators as well as Python iterators, D ranges, Rust iterators, and C# enumerators. Techniques
to turn internal iteration into external iteration or vice versa are for the most part outside of the scope of this
library (but see <a class="reference internal" href="sources.html#_CPPv2I0EX8VariableI5ValueEEN5annex5range4coroE" title="annex::range::coro"><code class="xref cpp cpp-any docutils literal"><span class="pre">coro</span></code></a>).</p>
<p>More can be learned on the subject from the very informative <a class="reference external" href="http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/">Iteration Inside and Out</a> series of posts by Bob Nystrom.</p>
</div>
</div>
<div class="section" id="the-users">
<h2>The users<a class="headerlink" href="#the-users" title="Permalink to this headline">¶</a></h2>
<p>When evaluating the merits and shortcomings of a range abstraction, it&#8217;s not often made explicit who are its users and
how it is intended they use the abstraction. This library considers two types of users:</p>
<ul class="simple">
<li>range implementers, who write code that provides instances or models that conform to the range abstraction</li>
<li>end users, who write code that uses and consumes those instances</li>
</ul>
<p>It is the author&#8217;s opinion that most range abstractions put too much emphasis on end users, with the net result that
implementing a model of a range is considered somewhat of an expert&#8217;s task. This approach makes sense when a range
library aims to be as complete as possible, with the expectation that end users will pick and choose the right tools
from the library to match their needs. Furthermore if end users are also expected to outnumber expert implementers then
putting the burden on experts makes sense, resulting in an economy of complexity.</p>
<p>On the other hand it is also the author&#8217;s opinion and experience that aiming for completeness is a tall order as the
need for new kinds of range frequently arises in end-user code. When existing libraries cannot fulfil that need this
leads to a a frustrating situation where the end users either have to use shortcuts or enlist the help of experts,
rather than tackle their need by writing a range themselves.</p>
<p>Conversely it is also the author&#8217;s opinion that if a range library wants to be as complete as possible, then we should
lend to the range implementers as much consideration as we do to end users. The easier it is to implement a range, the
faster the features land.</p>
</div>
<div class="section" id="iterator-shortcomings">
<h2>Iterator shortcomings<a class="headerlink" href="#iterator-shortcomings" title="Permalink to this headline">¶</a></h2>
<p>The need for a solution that starts from scratch rather than an iterative improvement on top of the pre-existing
iterator abstraction is best illustrated by a handful of examples. Consider the problem of iterating over only those
elements of a sequence that satisfy a predicate, oftentimes known as filtering:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">pred</span>     <span class="o">=</span> <span class="p">...;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span><span class="p">:</span> <span class="n">iterable</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// use the element</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The use of the predicate in the loop code makes it obvious that any iterator solution will need to somehow store <em>pred</em>
in order to use it for filtering. That leaves us faced with unsavoury design decisions:</p>
<ul>
<li><p class="first">Storing predicate copies in the iterator objects themselves requires the predicate to be copyable, not allowing for
move-only predicates since iterators must be copyable. Furthermore, copyable implies copy assignable whereas closure
objects (the values of lambda expressions) are popular function objects that may be copy constructible, but are not
even move assignable. The latter obstacle can be overcome, but at the cost of additional burden to range implementers.</p>
<p>Compounding this is the fact that iterators are meant to be used in pairs at the very least, leaving us with redundant
copies when there are two predicate copies per iterator pair where one predicate would be enough. Relaxing iterator
pairs to have possibly heterogeneous types looks like a possible remedy to this problem:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">pred</span>     <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">first</span>    <span class="o">=</span> <span class="n">make_filter_iterator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">iterable</span><span class="p">);</span>
<span class="c1">// N.B. we don&#39;t need a pred copy here</span>
<span class="k">auto</span> <span class="n">last</span>     <span class="o">=</span> <span class="n">make_filter_sentinel</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// use *first</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A shortcoming of this solution is that we&#8217;ve effectively enforced that filtering results in a forward-traversal only
scenario, since we cannot decrement <em>last</em> without having access to the predicate. The original loop code could
handle this case:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">pred</span>     <span class="o">=</span> <span class="p">...;</span>

<span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">iterable</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">iterable</span><span class="p">);</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">--</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">prev</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// use the element</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In other words, this solution makes it impossible to use a filter range with a bidirectional algorithm.</p>
</li>
<li><p class="first">Storing a shallow reference to the predicate can prevent code from returning down iterators:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">client</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iterable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">pred</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">elem</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
    <span class="c1">// result will outlive pred!</span>
    <span class="k">return</span> <span class="n">make_filter_iterable</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">iterable</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Storing a smart pointer to the predicate requires memory allocation, which we didn&#8217;t in the loop version.</p>
</li>
</ul>
</div>
<div class="section" id="self-contained-range-shortcomings">
<h2>Self-contained range shortcomings<a class="headerlink" href="#self-contained-range-shortcomings" title="Permalink to this headline">¶</a></h2>
<p>Andrei Alexandrescu&#8217;s <a class="reference external" href="https://accu.org/content/conf2009/AndreiAlexandrescu_iterators-must-go.pdf">Iterators Must Go</a> keynote and <a class="reference external" href="http://www.informit.com/articles/printerfriendly/1407357">On Iteration</a> article draw their own lists of criticisms of the
C++ iterator ecosystem and suggest self-contained ranges as a superior alternative. This paved the way for for D ranges
and Rust iterators. If we apply Alexandrescu&#8217;s insights to filtering, we can immediately notice that the problems we had
before don&#8217;t manifest:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">rng</span>    <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">pred</span>   <span class="o">=</span> <span class="p">...;</span>

<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">rng</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(;</span> <span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="n">result</span><span class="p">.</span><span class="n">popFront</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// use result.front()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="c1">// we are not limited to forward-only traversal</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">rng</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(;</span> <span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="n">result</span><span class="p">.</span><span class="n">popBack</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// use result.back()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rng</span><span class="p">));</span>
</pre></div>
</div>
<p>That is, the resulting ranges of calls to <em>filter</em> each store their own copy of the argument predicate without
compromising traversal capabilities or the the ability to return range objects down to a caller. As for assignment, we
could choose to give semantics of the whole range object in terms of its underlying parts (which naturally extends to
construction and move semantics):</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">rng</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">result_copy</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="c1">// both as valid as:</span>
<span class="k">auto</span> <span class="n">predicate_copy</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">rng_copy</span> <span class="o">=</span> <span class="n">rng</span><span class="p">;</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">rng</span><span class="p">);</span>
<span class="n">result_copy</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="c1">// both as valid as:</span>
<span class="n">predicate_copy</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
<span class="n">rng_copy</span> <span class="o">=</span> <span class="n">rng</span><span class="p">;</span>

<span class="c1">// similarly for construction &amp; assignment involving moves</span>
</pre></div>
</div>
<p>Unfortunately as we dig deeper we will see familiar demons rear their ugly heads again.</p>
<div class="section" id="how-self-contained-are-double-ended-and-random-access-ranges-really">
<h3>How self-contained are double-ended and random-access ranges really?<a class="headerlink" href="#how-self-contained-are-double-ended-and-random-access-ranges-really" title="Permalink to this headline">¶</a></h3>
<p>A strong premise of Alexandrescu-style ranges is that self-contained objects are harder to misuse than pair of
iterators. This leads to the following formulation for double-ended ranges (in C++ pseudo-code):</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Rng</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">AlexandrescuDoubleEndedRange</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">Rng</span> <span class="n">rng</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// a double-ended range is a forward range</span>
    <span class="p">{</span> <span class="n">rng</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">ContextualBool</span><span class="p">;</span>
    <span class="n">rng</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">rng</span><span class="p">.</span><span class="n">popFront</span><span class="p">();</span>

    <span class="c1">// double-ended  operations proper</span>
    <span class="n">rng</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="c1">// same type as the front</span>
    <span class="n">rng</span><span class="p">.</span><span class="n">popBack</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the original Alexandrescu article these were called bidirectional ranges, as a counterpart to C++-style bidirectional
iterators. However it should be noted that on their own these two concepts are not equivalent: a bidirectional iterator
can be moved some steps in one direction, then another number of steps back in the other directions (preconditions
permitting). A self-contained range can only be shrunk at either end and there is no &#8216;going back&#8217;. While in D these are
called <a class="reference external" href="https://dlang.org/phobos/std_range_primitives.html#isBidirectionalRange">bidirectional ranges</a> taking after the article, the Rust equivalent is called the <a class="reference external" href="https://doc.rust-lang.org/stable/std/iter/trait.DoubleEndedIterator.html">double-ended iterator</a>
<a class="footnote-reference" href="#double-ended" id="id1">[1]</a>. To avoid confusion we settle on double-ended terminology as well from now on, distinct from true
bidirectional traversal.</p>
<p>Since Alexandrescu also introduces the concept of ranges which iteration state can be saved, it appears that on the
surface the actual equivalent to C++-style bidirectional iterators are double-ended ranges that also support saving.
This equivalency does not lend itself well to code however:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="p">...;</span>

<span class="c1">// performs ++it 5 times</span>
<span class="n">advance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// use it</span>

<span class="c1">// circumstances may dictate that we step back to where we were earlier</span>
<span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">advance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Translated to double-ended ranges, we end up with:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">rng</span>  <span class="o">=</span> <span class="p">...;</span>

<span class="k">auto</span> <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">rng</span><span class="p">;</span>
<span class="c1">// performs rng.popFront() 5 times</span>
<span class="n">advance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// use rng</span>

<span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">advance</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">,</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With self-contained ranges, the programmer has to plan for and keep track of checkpoints ahead of of the bidirectional
code that will need them to restore ranges to one of their past states. Consider now a pair of bidirectional iterators
further subdivided into 3 subranges:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// invariant: [start, stop) is the whole original range</span>
<span class="k">auto</span> <span class="n">rng</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">stop</span>  <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
<span class="c1">// notional distance of the range</span>
<span class="c1">// auto const n = distance(start, stop);</span>

<span class="c1">// invariant: [start, first_sub_stop) is the first subrange</span>
<span class="k">auto</span> <span class="n">first_sub_stop</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

<span class="c1">// invariant: [first_sub_stop, second_sub_stop) is the second subrange</span>
<span class="k">auto</span> <span class="n">second_sub_stop</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">first_sub_stop</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

<span class="c1">// invariant: [second_sub_stop, stop) is the third subrange</span>
<span class="c1">// invariant: 0 &lt;= i &lt;= j &lt;= n</span>
</pre></div>
</div>
<p>This program fragment is a good demonstration of what bidirectional C++ iterators can do. While setting up the subrange
delimiters can be a costly operation in that it has linear time complexity with respect to range distance <span class="math">\(n\)</span>,
it&#8217;s not impossible or unusual that it is done in one single pass. Crucially, once those subdelimiters are computed they
can be adjusted very conveniently. For instance <code class="docutils literal"><span class="pre">--first_sub_stop</span></code> will at once shrink the first subrange from the end
while expanding the second subrange at the start. Provided that pre-conditions are met (i.e. <span class="math">\(i\)</span> is non-null) all
program invariants are preserved.</p>
<p>Is there an equivalent to this fragment but with D-style saveable, double-ended ranges? How hard would it be to adjust
the subranges after their initial setup? And finally, there is something very telling with the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">pred</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">rng</span>  <span class="o">=</span> <span class="p">...;</span>

<span class="c1">// Alexandrescu-style filter range</span>
<span class="k">auto</span> <span class="n">filtered</span> <span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rng</span><span class="p">));</span>

<span class="k">auto</span> <span class="n">first_subrange</span>  <span class="o">=</span> <span class="n">compute_first_subrange</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">auto</span> <span class="n">second_subrange</span> <span class="o">=</span> <span class="n">compute_second_subrange</span><span class="p">(...);</span>
<span class="k">auto</span> <span class="n">third_subrange</span>  <span class="o">=</span> <span class="n">compute_third_subrdang</span><span class="p">(...);</span>
</pre></div>
</div>
<p>If the subranges are computed by saving <em>filtered</em>, that means they each have their own copy of <em>pred</em> (the one that was
moved into <em>filtered</em>) for a total of 4 copies! That&#8217;s just as much as the iterator version would have, namely a copy
for each of <em>start</em>, <em>first_sub_stop</em>, <em>second_sub_stop</em>, and <em>stop</em>. In other words the Alexandrescu approach really is
self-contained for the common scenario of a range from start to end, but that self-containment breaks down when a range
needs to be subdivided further.</p>
<p>Random-access ranges <a class="footnote-reference" href="#random-access" id="id2">[2]</a> expose this breakdown very explicitly:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">AlexandrescuDoubleEndedRange</span><span class="p">{</span><span class="n">Rng</span><span class="p">}</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">AlexandrescuRandomAccessRange</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">Rng</span> <span class="n">rng</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// extremely simplified</span>
    <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// same type as front() and back()</span>
<span class="p">};</span>
</pre></div>
</div>
<p>That is, elements can be accessed using integral offsets. Since integral offsets can be incremented or decremented by
nearly arbitrary amounts, Alexandrescu-style random-access ranges are not very different from pairs of random-access
iterators.</p>
<table class="docutils footnote" frame="void" id="double-ended" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Rust uses &#8216;iterator&#8217; in its terminology but does use and implement Alexandrescu-style self-contained
ranges, not C++-style iterators</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="random-access" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>the random-access ranges and iterators that D and Rust ended up defining differ slightly from Andrei
Alexandrescu&#8217;s original formulation, the strawman C++ concept here is closer to the former than to the latter</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="a-hybrid-approach">
<h2>A hybrid approach<a class="headerlink" href="#a-hybrid-approach" title="Permalink to this headline">¶</a></h2>
<p>Two concerns have dominated the discussion so far:</p>
<ul class="simple">
<li>The need to package related information together in one object (e.g. the filtering predicate of a filtering range).
This concern is oriented around construction and argument passing, including copy semantics (&#8216;saving&#8217; in Alexandrescu
terminology). Correct lifetime semantics is a staple of C++ programming that is not as readily alleviated as it can be
in another language. Garbage collection can give great mileage to double-ended ranges together with range saving, but
that is not an option here.</li>
<li>The need to maintain functionality parity with iterators, in particular with regards to bidirectional and
random-access algorithms.</li>
</ul>
<p>This library aims to defend and implement a dual interface approach, with a self-contained range object concept that
comes with individual position objects. End users need only be concerned with an interface that deals in self-contained
ranges, while range implementers will focus on the position interfaces.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Motivation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#iteration">Iteration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#internal-and-external-iteration">Internal and external iteration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-users">The users</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterator-shortcomings">Iterator shortcomings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#self-contained-range-shortcomings">Self-contained range shortcomings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#how-self-contained-are-double-ended-and-random-access-ranges-really">How self-contained are double-ended and random-access ranges really?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#a-hybrid-approach">A hybrid approach</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="open_questions.html">Open questions</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="quickstart.html"
                        title="previous chapter">Quickstart</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scope.html"
                        title="next chapter">Scope</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/motivation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="scope.html" title="Scope"
             >next</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="Quickstart"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">annex-range 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, mickk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5a0.
    </div>
  </body>
</html>