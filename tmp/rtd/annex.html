

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Annex quick reference &mdash; annex-range 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="annex-range 0.1.0 documentation" href="index.html"/>
        <link rel="up" title="Reference" href="reference.html"/>
        <link rel="next" title="Open questions" href="open_questions.html"/>
        <link rel="prev" title="Common" href="common.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> annex-range
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="motivation.html">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="concepts.html">Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="operations.html">Operations &amp; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sources.html">Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumers.html">Consumers</a></li>
<li class="toctree-l2"><a class="reference internal" href="transformations.html">Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="compositions.html">Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrangements.html">Arrangements</a></li>
<li class="toctree-l2"><a class="reference internal" href="common.html">Common</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Annex quick reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#concepts-for-variables">Concepts for variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#forward-storing">Forward Storing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function">Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-model">Simple model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concepts">Concepts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#base-convenience-concepts">Base &amp; convenience concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#construction">Construction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterators">Iterators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invokation">Invokation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#various">Various</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#how-to-read-the-reference">How to read the reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="open_questions.html">Open questions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">annex-range</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 







<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="reference.html">Reference</a> &raquo;</li>
      
    <li>Annex quick reference</li>
    <li class="wy-breadcrumbs-aside">
      
          
          <a href="_sources/annex.rst.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="annex-quick-reference">
<h1>Annex quick reference<a class="headerlink" href="#annex-quick-reference" title="Permalink to this headline">¶</a></h1>
<p>This library is part of the annex series of libraries and as such relies on certain conventions and pre-defined
concepts. The most common and important ones are briefly documented here, while the library proper is documented in the
rest of the <a class="reference internal" href="reference.html"><span class="doc">Reference</span></a>.</p>
<div class="section" id="concepts-for-variables">
<span id="id1"></span><h2>Concepts for variables<a class="headerlink" href="#concepts-for-variables" title="Permalink to this headline">¶</a></h2>
<p>The annex series of libraries follow the philosophy of <a class="reference external" href="http://mickk-on-cpp.github.io">Concepts for variables</a>. Not all concepts are written for
variables however, but the two can be easily distinguished:</p>
<ul>
<li><p class="first">concepts for variables introduce a <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a> constraint on at least one parameter, but not necessarily all:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Variable</span> <span class="n">Var</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="kt">bool</span> <span class="n">Invokable</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
</li>
<li><p class="first">concepts for types follow the naming convention of ending in <code class="docutils literal"><span class="pre">-Type</span></code>, starting with the trivial concept <a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type"><code class="xref cpp cpp-any docutils literal"><span class="pre">Type</span></code></a>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="kt">bool</span> <span class="n">Type</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">Type</span><span class="p">{</span><span class="n">X</span><span class="p">}</span> <span class="n">concept</span> <span class="kt">bool</span> <span class="n">StorableType</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="forward-storing">
<span id="id3"></span><h2>Forward Storing<a class="headerlink" href="#forward-storing" title="Permalink to this headline">¶</a></h2>
<p>It&#8217;s common in C++ for generic data to come with factory function templates, to reduce boilerplate thanks to template
argument deduction. <code class="xref cpp cpp-any docutils literal"><span class="pre">std::make_tuple</span></code> is a very prominent example of such and many factories use the <code class="docutils literal"><span class="pre">make_*</span></code> naming
convention:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="s">&quot;bcd&quot;</span><span class="p">);</span>
<span class="c1">// more convenient than:</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="s">&quot;bcd&quot;</span> <span class="p">};</span>
</pre></div>
</div>
<p>Unfortunately, the generic <code class="xref cpp cpp-any docutils literal"><span class="pre">std::tuple</span></code> actually comes with <em>three</em> factories: <code class="xref cpp cpp-any docutils literal"><span class="pre">std::make_tuple</span></code>, <code class="xref cpp cpp-any docutils literal"><span class="pre">std::tie</span></code>, and
<code class="xref cpp cpp-any docutils literal"><span class="pre">std::forward_as_tuple</span></code> which each have a particular purpose. The annex series of libraries instead typically provides
one factory per generic type which can serve those three purposes simultaneously:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">std::make_tuple(a,</span> <span class="pre">std::ref(b))</span></code></td>
<td><code class="docutils literal"><span class="pre">annex::tuples::tuple(decay(a),</span> <span class="pre">b)</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">std::tie(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></td>
<td><code class="docutils literal"><span class="pre">annex::tuples::tuple(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">std::forward_as_tuple(a,</span> <span class="pre">std::move(b))</span></code></td>
<td><code class="docutils literal"><span class="pre">annex::tuples::tuple(a,</span> <span class="pre">std::move(b))</span></code> <a class="footnote-reference" href="#tuple-note" id="id4">[1]</a></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tuple-note" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td><code class="docutils literal"><span class="pre">std::forward_as_tuple(0)</span></code> and <code class="docutils literal"><span class="pre">annex::tuples::tuple(0)</span></code> differ in that the former creates an
<code class="docutils literal"><span class="pre">std::tuple&lt;int&amp;&amp;&gt;</span></code>, the latter an <code class="docutils literal"><span class="pre">std::tuple&lt;int&gt;</span></code>.</td></tr>
</tbody>
</table>
<p>When the circumstances call for it a traditional, additional <code class="docutils literal"><span class="pre">make_*</span></code> factory is sometimes provided as well.</p>
</div>
<div class="section" id="function">
<span id="id5"></span><h2>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h2>
<p>The annex series of libraries attempts to avoid namespace-scope functions and function templates, favouring instead
namespace-scope constant function objects or variable templates. That is, something such as <code class="docutils literal"><span class="pre">annex::decay(0)</span></code> calls a
particular <code class="docutils literal"><span class="pre">operator()</span></code> overload on a constant named <code class="docutils literal"><span class="pre">decay</span></code>. The motivation behind this is as follows:</p>
<ul>
<li><p class="first">to avoid unwanted and uncontrolled use of Argument-Dependent Lookup</p>
</li>
<li><p class="first">to encourage and facilitate higher-order manipulation; e.g. <code class="docutils literal"><span class="pre">auto&amp;</span> <span class="pre">decay</span> <span class="pre">=</span> <span class="pre">annex::decay;</span></code> is an easy way to alias a
<a class="reference internal" href="#function"><span class="std std-ref">Function</span></a>. Perhaps more importantly the referred <code class="docutils literal"><span class="pre">decay</span></code> object can be passed to another <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a> using
this very same mechanism:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">decay</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">decay</span></code> were a function template, something such as the following would have to be used as a verbose workaround:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">function_object</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// explicitly qualify to avoid unwanted ADL</span>
    <span class="k">return</span> <span class="n">annex</span><span class="o">::</span><span class="n">decay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">function_object</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>Transforming the function template into a function object so that it can be passed as an argument is pure boilerplate.
In a sense the annex libraries take this precaution ahead of time for convenience to the user.</p>
</li>
</ul>
<p>Eric Niebler elaborates on the benefits of function-like objects in his post <a class="reference external" href="http://ericniebler.com/2014/10/21/customization-point-design-in-c11-and-beyond/">Customization Point Design in C++11 and
Beyond</a>, especially as it relates to ADL.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">annex functions are not customization points and do not perform ADL on behalf of the user unless otherwise
specified.</p>
</div>
<p>For conciseness, and because their nature as objects is mostly an implementation detail, function-like objects are still
referred to as <em>functions</em>. Additionally, functions are consistently defined as follows throughout annex libraries
(e.g. for an assumed <code class="docutils literal"><span class="pre">foo</span></code> function):</p>
<ul>
<li><p class="first">the constant lives in its relevant annex namespace or subnamespace, e.g. <code class="docutils literal"><span class="pre">annex::tuples::foo</span></code></p>
</li>
<li><p class="first">it has type <code class="docutils literal"><span class="pre">annex::tuples::functors::foo</span> <span class="pre">const&amp;</span></code></p>
</li>
<li><p class="first">there is an associated <code class="docutils literal"><span class="pre">annex::tuples::result_of::foo&lt;X,</span> <span class="pre">Y,</span> <span class="pre">Z&gt;</span></code> alias which is short for:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">decltype</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">some functions are parametrised over types and constants, in which case they are constant templates e.g.
<code class="docutils literal"><span class="pre">annex::tuples::foo&lt;int,</span> <span class="pre">0&gt;</span></code> of type <code class="docutils literal"><span class="pre">annex::tuples::functors::foo&lt;int,</span> <span class="pre">0&gt;</span> <span class="pre">const&amp;</span></code> and with alias
<code class="docutils literal"><span class="pre">annex::tuples::result_of::foo&lt;int,</span> <span class="pre">0,</span> <span class="pre">X,</span> <span class="pre">Y,</span> <span class="pre">Z&gt;</span></code> short for:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">decltype</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">)</span>
</pre></div>
</div>
<p>Due to limitations in the language, constant templates that accept a variadic number of arguments cannot have a
<code class="docutils literal"><span class="pre">result_of</span></code> alias:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">reorder_to</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">);</span>
<span class="c1">// not possible:</span>
<span class="c1">// using res_t = annex::tuples::result_of::reorder_to&lt;int, char, decltype(tup)&amp;&gt;;</span>
</pre></div>
</div>
</li>
<li><p class="first">functions have additional functionality, e.g. they can be partially applied:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">partial</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>A call to <code class="docutils literal"><span class="pre">partial</span></code> produces a new function-like object, which can in turn be subject to a call to <code class="docutils literal"><span class="pre">partial</span></code>
again, or be invoked with final arguments. Many functions take <code class="docutils literal"><span class="pre">partial</span></code> into account when it comes to parameter
order to help with higher-order usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">succ</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">arg</span><span class="p">;</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">map</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">succ</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="simple-model">
<span id="id6"></span><h2>Simple model<a class="headerlink" href="#simple-model" title="Permalink to this headline">¶</a></h2>
<p>A <em>simple model</em> of a concept is intended to be the least surprising possible type which fulfils this concept, given
some parameters. In particular, simple models associated with a factory <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a> behave according to the
following (e.g. assuming an associated <code class="docutils literal"><span class="pre">annex::ns::foo</span></code> factory):</p>
<ul>
<li><p class="first">the name of the class or class template that will model the concept follows closely that of the <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a>, e.g.
<code class="docutils literal"><span class="pre">annex::ns::foo_type</span></code></p>
</li>
<li><p class="first">a valid call <code class="docutils literal"><span class="pre">annex::ns::foo(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> produces an <code class="docutils literal"><span class="pre">annex::ns::foo_type&lt;A,</span> <span class="pre">B,</span> <span class="pre">C&gt;</span></code> result, where <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code>, and
<code class="docutils literal"><span class="pre">C</span></code> are types related to <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, and <code class="docutils literal"><span class="pre">c</span></code> respectively (e.g. a <a class="reference internal" href="#forward-storing"><span class="std std-ref">forward storing</span></a>
<a class="reference internal" href="#function"><span class="std std-ref">Function</span></a> called as <code class="docutils literal"><span class="pre">annex::ns::foo(i,</span> <span class="pre">std::move(j),</span> <span class="pre">0)</span></code> yields an <code class="docutils literal"><span class="pre">annex::ns::foo_type&lt;int&amp;,</span> <span class="pre">int,</span> <span class="pre">int&gt;</span></code>
assuming all <code class="docutils literal"><span class="pre">int</span></code> arguments); while <code class="docutils literal"><span class="pre">annex::ns::foo&lt;X,</span> <span class="pre">Y,</span> <span class="pre">Z&gt;(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> would produce an <code class="docutils literal"><span class="pre">annex::ns::foo_type&lt;X,</span>
<span class="pre">Y,</span> <span class="pre">Z,</span> <span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C&gt;</span></code> result</p>
</li>
<li><p class="first">some or all of the parameters used to construct the simple model may be available as public data members:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">range</span> <span class="o">=</span> <span class="n">annex</span><span class="o">::</span><span class="n">range</span><span class="p">;</span>
<span class="c1">// decltype( res ) is intended as the least surprising model of a range of ints from 0 to 6 exclusive</span>
<span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">range</span><span class="o">::</span><span class="n">interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">// names of data members documented by interval</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">res</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">from</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">res</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">to</span>   <span class="o">==</span> <span class="mi">6</span> <span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The data members are made public so that the values used to construct the simple model can be retrieved, which
usually takes place <strong>after</strong> normal usage. Hence the members are able to be accessed mutably so as to allow
moves.</p>
<p class="last">However those data members are used by the type in order to fulfil the concept operations and are not merely
copies of the parameters used at construction&#8211;the user should store its own if that&#8217;s what they need. This means
that modifying those members before or during use of the associated concept operations should be done at own risk,
and considered extremely brittle.</p>
</div>
</li>
</ul>
<p>Because a simple model is closely associated to its factory <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a>, its precise capabilities are normally
described in the function documentation.</p>
</div>
<div class="section" id="concepts">
<h2>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="base-convenience-concepts">
<h3>Base &amp; convenience concepts<a class="headerlink" href="#base-convenience-concepts" title="Permalink to this headline">¶</a></h3>
<dl class="concept">
<dt>
template&lt;typename <code class="descname">X</code>&gt;</dt>
<dt id="_CPPv2I0EN5annex4TypeE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Type</code><a class="headerlink" href="#_CPPv2I0EN5annex4TypeE" title="Permalink to this definition">¶</a></dt>
<dd><p>The trivial concept satisfied by any type. It&#8217;s used as a shortcut for template introductions:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="p">{</span><span class="n">Item</span><span class="p">}</span> <span class="n">Item</span><span class="o">*</span> <span class="n">addressof</span><span class="p">(</span><span class="n">Item</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt>
template&lt;typename ...<code class="descname">Xs</code>&gt;</dt>
<dt id="_CPPv2IDpEN5annex5TypesE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Types</code> = (... &amp;&amp; Type&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEN5annex5TypesE" title="Permalink to this definition">¶</a></dt>
<dd><p>A variadic variant of <a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type"><code class="xref cpp cpp-any docutils literal"><span class="pre">Type</span></code></a>, for introducing multiple parameters and/or a pack:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Types</span><span class="p">{</span><span class="n">First</span><span class="p">,</span> <span class="p">...</span> <span class="n">Rest</span><span class="p">}</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">First</span><span class="o">&amp;&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="n">Rest</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">X</code>}</dt>
<dt id="_CPPv2I0EX4TypeI1XEEN5annex8VariableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Variable</code><a class="headerlink" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="Permalink to this definition">¶</a></dt>
<dd><p>The basis of <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a>. It is the minimal constraint for the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Variable</span><span class="p">{</span><span class="n">Var</span><span class="p">}</span> <span class="k">struct</span> <span class="n">generic_data</span> <span class="p">{</span> <span class="n">Var</span> <span class="n">member</span><span class="p">;</span> <span class="p">};</span>

<span class="n">Variable</span><span class="p">{</span><span class="n">Var</span><span class="p">}</span> <span class="kt">void</span> <span class="n">generic_function</span><span class="p">(</span><span class="n">generic_data</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span> <span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}</dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Variables</code> = (... &amp;&amp; Variable&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="Permalink to this definition">¶</a></dt>
<dd><p>A variadic variant of <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a>, for introducing multiple parameters and/or a pack.</p>
</dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Pack</code>}</dt>
<dt id="_CPPv2IDpEX5TypesIsp4PackEEN5annex12NonEmptyPackE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">NonEmptyPack</code> = sizeof...(Pack) != 0<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp4PackEEN5annex12NonEmptyPackE" title="Permalink to this definition">¶</a></dt>
<dd><p>A pseudo-concept for constraining variadic templates that are not valid for empty packs.</p>
</dd></dl>

</div>
<div class="section" id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="Permalink to this headline">¶</a></h3>
<p>These concepts are nearly equivalent to the corresponding trait (e.g. <code class="xref cpp cpp-any docutils literal"><span class="pre">std::is_constructible_v</span></code> and so on), but in
<a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a> form:</p>
<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename ...<code class="descname">Inits</code>&gt;</dt>
<dt id="_CPPv2I_8VariableDpEN5annex13ConstructibleE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Constructible</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex13ConstructibleE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename <code class="descname">Init</code>&gt;</dt>
<dt id="_CPPv2I_8Variable0EN5annex10AssignableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Assignable</code><a class="headerlink" href="#_CPPv2I_8Variable0EN5annex10AssignableE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex17MoveConstructibleE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">MoveConstructible</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex17MoveConstructibleE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex14MoveAssignableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">MoveAssignable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex14MoveAssignableE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex17CopyConstructibleE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">CopyConstructible</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex17CopyConstructibleE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex14CopyAssignableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">CopyAssignable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex14CopyAssignableE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>As well as some shortcuts:</p>
<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex7MovableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Movable</code> = MoveConstructible&lt;Var&gt; &amp;&amp; MoveAssignable&lt;Var&gt;<a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex7MovableE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex8CopyableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Copyable</code> = CopyConstructible&lt;Var&gt; &amp;&amp; CopyAssignable&lt;Var&gt;<a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex8CopyableE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>There are construction concepts that make it easy to constrain factory <a class="reference internal" href="#function"><span class="std std-ref">functions</span></a>:</p>
<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">X</code>}</dt>
<dt id="_CPPv2I0EX4TypeI1XEEN5annex15ForwardableTypeE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardableType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI1XEEN5annex15ForwardableTypeE" title="Permalink to this definition">¶</a></dt>
<dd><p>For factories that use <a class="reference internal" href="#forward-storing"><span class="std std-ref">Forward Storing</span></a> for their arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ForwardableType</span><span class="p">{</span><span class="n">Param</span><span class="p">}</span> <span class="n">foo_type</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="n">Param</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">foo_type</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX4TypeI3VarEEN5annex12StorableTypeE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">StorableType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI3VarEEN5annex12StorableTypeE" title="Permalink to this definition">¶</a></dt>
<dd><p>For factories that decay their arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">StorableType</span><span class="p">{</span><span class="n">Param</span><span class="p">}</span> <span class="n">foo_type</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;&gt;</span> <span class="n">make_foo</span><span class="p">(</span><span class="n">Param</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">foo_type</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<p>There also are variadic versions:</p>
<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}</dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex16ForwardableTypesE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardableTypes</code> = (... &amp;&amp; ForwardableType&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex16ForwardableTypesE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}</dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex13StorableTypesE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">StorableTypes</code> = (... &amp;&amp; StorableType&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex13StorableTypesE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}</dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex18MoveConstructiblesE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">MoveConstructibles</code> = (... &amp;&amp; MoveConstructible&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex18MoveConstructiblesE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="iterators">
<h3>Iterators<a class="headerlink" href="#iterators" title="Permalink to this headline">¶</a></h3>
<p>These correspond to the Standard iterator concepts, but in <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a> form:</p>
<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex13InputIteratorE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InputIterator</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex13InputIteratorE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX8VariableI3VarEEN5annex13InputIteratorE" title="annex::InputIterator">InputIterator</a>{<code class="descname">It</code>}</dt>
<dt id="_CPPv2I0EX13InputIteratorI2ItEEN5annex15ForwardIteratorE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardIterator</code><a class="headerlink" href="#_CPPv2I0EX13InputIteratorI2ItEEN5annex15ForwardIteratorE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX13InputIteratorI2ItEEN5annex15ForwardIteratorE" title="annex::ForwardIterator">ForwardIterator</a>{<code class="descname">It</code>}</dt>
<dt id="_CPPv2I0EX15ForwardIteratorI2ItEEN5annex21BidirectionalIteratorE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">BidirectionalIterator</code><a class="headerlink" href="#_CPPv2I0EX15ForwardIteratorI2ItEEN5annex21BidirectionalIteratorE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX15ForwardIteratorI2ItEEN5annex21BidirectionalIteratorE" title="annex::BidirectionalIterator">BidirectionalIterator</a>{<code class="descname">It</code>}</dt>
<dt id="_CPPv2I0EX21BidirectionalIteratorI2ItEEN5annex20RandomAccessIteratorE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">RandomAccessIterator</code><a class="headerlink" href="#_CPPv2I0EX21BidirectionalIteratorI2ItEEN5annex20RandomAccessIteratorE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>As well as the non-standard:</p>
<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex8IterableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Iterable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex8IterableE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">iter</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A variable which can provide a readable, notional sequence of elements via models of <a class="reference internal" href="#_CPPv2I0EX8VariableI3VarEEN5annex13InputIteratorE" title="annex::InputIterator"><code class="xref cpp cpp-any docutils literal"><span class="pre">InputIterator</span></code></a> provided
through the <code class="xref cpp cpp-any docutils literal"><span class="pre">ops::begin</span></code> and <code class="xref cpp cpp-any docutils literal"><span class="pre">ops::end</span></code> operations:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="c1">// use elem</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Requirements:</th><td class="field-body"><code class="xref cpp cpp-any docutils literal"><span class="pre">ops::begin(iter)</span></code>, <code class="xref cpp cpp-any docutils literal"><span class="pre">ops::end(iter)</span></code>: obtain an initial and final <a class="reference internal" href="#_CPPv2I0EX8VariableI3VarEEN5annex13InputIteratorE" title="annex::InputIterator"><code class="xref cpp cpp-any docutils literal"><span class="pre">InputIterator</span></code></a> into
the notional sequence respectively&#8212;both results must have identical types, and <em>last</em> must be reachable from
<em>first</em></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="invokation">
<h3>Invokation<a class="headerlink" href="#invokation" title="Permalink to this headline">¶</a></h3>
<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename ...<code class="descname">Args</code>&gt;</dt>
<dt id="_CPPv2I_8VariableDpEN5annex9InvokableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Invokable</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">var</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>An invokable variable, given some arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">()...);</span>
<span class="c1">// n.b. ------^^^^^^^^^^^^^^^^^^^^^^</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>It should be noted that while <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable::Var"><code class="xref cpp cpp-any docutils literal"><span class="pre">Var</span></code></a> is a <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a> (making <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable</span></code></a> a <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">concept for variables</span></a>), inside the associated expression the variable that stands for it is forwarded. This
makes it possible to correctly constrain the following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Func</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">example</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Params</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">requires</span>
        <span class="c1">// for the first invocation</span>
        <span class="n">Invokable</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Params</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span><span class="o">&gt;</span>

        <span class="c1">// for the final invocation</span>
        <span class="o">&amp;&amp;</span> <span class="n">Invokable</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">Params</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">params</span><span class="p">...);</span>
    <span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">params</span><span class="p">...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note also that the <code class="docutils literal"><span class="pre">Args</span></code> are not constrained to be models of <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a>.</p>
</dd></dl>

<dl class="concept">
<dt>
template&lt;typename <code class="descname">Result</code>, <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename ...<code class="descname">Args</code>&gt;</dt>
<dt id="_CPPv2I0_8VariableDpEN5annex11InvokableAsE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InvokableAs</code><a class="headerlink" href="#_CPPv2I0_8VariableDpEN5annex11InvokableAsE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">var</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Similar to <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable</span></code></a> except specified in terms of <code class="xref cpp cpp-any docutils literal"><span class="pre">annex::invoke_as&lt;Result&gt;</span></code> instead of <code class="xref cpp cpp-any docutils literal"><span class="pre">annex::invoke</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">annex</span><span class="o">::</span><span class="n">invoke_as</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">()...);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename ...<code class="descname">Args</code>&gt;</dt>
<dt id="_CPPv2I_8VariableDpEN5annex9PredicateE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Predicate</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">var</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A refinement of <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable&lt;Var,</span> <span class="pre">Args...&gt;</span></code></a>, which further requires that the invocation result must be a
model of <code class="xref cpp cpp-any docutils literal"><span class="pre">ContextualBool</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>As a refinement of <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable</span></code></a> the associated expression still involves the forwarding of <em>var</em>. Care should be
taken if a predicate will be used repeatedly, as is typical. E.g. the following is a correctly constrained
implementation of logical conjunction with perfectly-forwarded parameters:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Pred</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">all</span><span class="p">(</span><span class="n">Pred</span><span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">requires</span> <span class="p">(...</span> <span class="o">&amp;&amp;</span> <span class="n">Predicate</span><span class="o">&lt;</span><span class="n">meta</span><span class="o">::</span><span class="n">as_const</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(...</span> <span class="o">&amp;&amp;</span> <span class="n">as_const</span><span class="p">(</span><span class="n">pred</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename <code class="descname">Lhs</code>, typename <code class="descname">Rhs</code> = <a class="reference internal" href="#_CPPv2I_8Variable00EN5annex11EquivalenceE" title="annex::Equivalence::Lhs">Lhs</a>&gt;</dt>
<dt id="_CPPv2I_8Variable00EN5annex11EquivalenceE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Equivalence</code><a class="headerlink" href="#_CPPv2I_8Variable00EN5annex11EquivalenceE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">var</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A refinement of <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate</span></code></a> (see additional requirements) where <em>var</em> induces an equivalence relation, meaning it
respects the axioms of reflexivity, symmetry, and transitivity when called on arguments with types <a class="reference internal" href="#_CPPv2I_8Variable00EN5annex11EquivalenceE" title="annex::Equivalence::Lhs"><code class="xref cpp cpp-any docutils literal"><span class="pre">Lhs</span></code></a> or <a class="reference internal" href="#_CPPv2I_8Variable00EN5annex11EquivalenceE" title="annex::Equivalence::Rhs"><code class="xref cpp cpp-any docutils literal"><span class="pre">Rhs</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Additional requirements:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first"><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Var,</span> <span class="pre">Lhs,</span> <span class="pre">Lhs&gt;</span></code></a></p>
<p><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Var,</span> <span class="pre">Rhs,</span> <span class="pre">Rhs&gt;</span></code></a></p>
<p><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Var,</span> <span class="pre">Lhs,</span> <span class="pre">Rhs&gt;</span></code></a></p>
<p class="last"><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Var,</span> <span class="pre">Rhs,</span> <span class="pre">Rhs&gt;</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="various">
<h3>Various<a class="headerlink" href="#various" title="Permalink to this headline">¶</a></h3>
<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex8IntegralE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Integral</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex8IntegralE" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref cpp cpp-any docutils literal"><span class="pre">std::is_integral_v</span></code> in <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a> form.</p>
</dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex14SignedIntegralE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">SignedIntegral</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex14SignedIntegralE" title="Permalink to this definition">¶</a></dt>
<dd><p>A refinement of <a class="reference internal" href="#_CPPv2I0EX8VariableI3VarEEN5annex8IntegralE" title="annex::Integral"><code class="xref cpp cpp-any docutils literal"><span class="pre">Integral</span></code></a> for signed integer types.</p>
</dd></dl>

<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Lhs</code>, <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Rhs</code> = Lhs&gt;</dt>
<dt id="_CPPv2I_8Variable_8VariableEN5annex18EqualityComparableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">EqualityComparable</code><a class="headerlink" href="#_CPPv2I_8Variable_8VariableEN5annex18EqualityComparableE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Lhs</span> <span class="n">lhs</span><span class="p">;</span> <span class="n">Rhs</span> <span class="n">rhs</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Decidable equality relation between possibly heterogeneous variables. This must induce an equivalence relation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><code class="docutils literal"><span class="pre">lhs</span> <span class="pre">==</span> <span class="pre">rhs</span></code>, <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">!=</span> <span class="pre">rhs</span></code> which must be contextual booleans</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="type">
<dt>
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX4TypeI3VarEEN5annex22nullable_dereference_tE">
<em class="property">using </em><code class="descclassname"></code><code class="descname">nullable_dereference_t</code><a class="headerlink" href="#_CPPv2I0EX4TypeI3VarEEN5annex22nullable_dereference_tE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">nullable</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>The result type of <code class="docutils literal"><span class="pre">*std::forward&lt;Var&gt;(nullable)</span></code></p>
</dd></dl>

<dl class="type">
<dt>
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX4TypeI3VarEEN5annex18nullable_element_tE">
<em class="property">using </em><code class="descclassname"></code><code class="descname">nullable_element_t</code><a class="headerlink" href="#_CPPv2I0EX4TypeI3VarEEN5annex18nullable_element_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying element type of a nullable variable.</p>
</dd></dl>

<dl class="concept">
<dt>
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}</dt>
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex8NullableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Nullable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex8NullableE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">nullable</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A possibly null variable which can be tested for, indirected if non-null, and reset to a null state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first"><code class="docutils literal"><span class="pre">nullable</span></code>: must be a contextual <code class="docutils literal"><span class="pre">bool</span></code> for testing the null state; <code class="docutils literal"><span class="pre">true</span></code> indicates a non-null <em>nullable</em></p>
<p><code class="docutils literal"><span class="pre">nullable</span> <span class="pre">=</span> <span class="pre">{}</span></code>: reset the variable to a null state, such that <code class="docutils literal"><span class="pre">!nullable</span></code> holds afterwards</p>
<p><code class="docutils literal"><span class="pre">*std::forward&lt;Var&gt;(nullable)</span></code>: access to the indirected value on the precondition that <em>nullable</em> is non-null</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Associated types:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last"><a class="reference internal" href="#_CPPv2I0EX4TypeI3VarEEN5annex22nullable_dereference_tE" title="annex::nullable_dereference_t"><code class="xref cpp cpp-any docutils literal"><span class="pre">nullable_dereference_t</span></code></a>, <a class="reference internal" href="#_CPPv2I0EX4TypeI3VarEEN5annex18nullable_element_tE" title="annex::nullable_element_t"><code class="xref cpp cpp-any docutils literal"><span class="pre">nullable_element_t</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="concept">
<dt>
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename <code class="descname">Stream</code> = std::ostream&amp;&gt;</dt>
<dt id="_CPPv2I_8Variable0EN5annex17StreamExtractableE">
<em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">StreamExtractable</code><a class="headerlink" href="#_CPPv2I_8Variable0EN5annex17StreamExtractableE" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">extractable</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A variable which can be extracted from a stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expression:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><code class="docutils literal"><span class="pre">std::declval&lt;Stream&amp;&gt;()</span> <span class="pre">&gt;&gt;</span> <span class="pre">extractable</span></code>: extract into variable</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="open_questions.html" class="btn btn-neutral float-right" title="Open questions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="common.html" class="btn btn-neutral" title="Common" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, mickk.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>