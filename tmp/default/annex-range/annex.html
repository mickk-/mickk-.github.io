<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Annex quick reference &#8212; annex-range 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Open questions" href="open_questions.html" />
    <link rel="prev" title="Common" href="common.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="open_questions.html" title="Open questions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="common.html" title="Common"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">annex-range 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="reference.html" accesskey="U">Reference</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="annex-quick-reference">
<h1>Annex quick reference<a class="headerlink" href="#annex-quick-reference" title="Permalink to this headline">¶</a></h1>
<p>This library is part of the annex series of libraries and as such relies on certain conventions and pre-defined
concepts. The most common and important ones are briefly documented here, while the library proper is documented in the
rest of the <a class="reference internal" href="reference.html"><span class="doc">Reference</span></a>.</p>
<div class="section" id="concepts-for-variables">
<span id="id1"></span><h2>Concepts for variables<a class="headerlink" href="#concepts-for-variables" title="Permalink to this headline">¶</a></h2>
<p>The annex series of libraries follow the philosophy of <a class="reference external" href="http://mickk-on-cpp.github.io">Concepts for variables</a>. Not all concepts are written for
variables however, but the two can be easily distinguished:</p>
<ul>
<li><p class="first">concepts for variables introduce a <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a> constraint on at least one parameter, but not necessarily all:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Variable</span> <span class="n">Func</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="kt">bool</span> <span class="n">Invokable</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
</li>
<li><p class="first">concepts for types follow the naming convention of ending in <code class="docutils literal"><span class="pre">-Type</span></code>, starting with the trivial concept <a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type"><code class="xref cpp cpp-any docutils literal"><span class="pre">Type</span></code></a>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="kt">bool</span> <span class="n">Type</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">Type</span><span class="p">{</span><span class="n">X</span><span class="p">}</span> <span class="n">concept</span> <span class="kt">bool</span> <span class="n">StorableType</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="forward-storing">
<span id="id3"></span><h2>Forward Storing<a class="headerlink" href="#forward-storing" title="Permalink to this headline">¶</a></h2>
<p>It&#8217;s common in C++ for generic data to come with factory function templates, to reduce boilerplate thanks to template
argument deduction. <code class="xref cpp cpp-any docutils literal"><span class="pre">std::make_tuple</span></code> is a very prominent example of such and many factories use the <code class="docutils literal"><span class="pre">make_*</span></code> naming
convention:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="s">&quot;bcd&quot;</span><span class="p">);</span>
<span class="c1">// more convenient than:</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="s">&quot;bcd&quot;</span> <span class="p">};</span>
</pre></div>
</div>
<p>Unfortunately, the generic <code class="xref cpp cpp-any docutils literal"><span class="pre">std::tuple</span></code> actually comes with <em>three</em> factories: <code class="xref cpp cpp-any docutils literal"><span class="pre">std::make_tuple</span></code>, <code class="xref cpp cpp-any docutils literal"><span class="pre">std::tie</span></code>, and
<code class="xref cpp cpp-any docutils literal"><span class="pre">std::forward_as_tuple</span></code> which each have a particular purpose. The annex series of libraries instead typically provides
one factory per generic type which can serve those three purposes simultaneously:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">std::make_tuple(a,</span> <span class="pre">std::ref(b))</span></code></td>
<td><code class="docutils literal"><span class="pre">annex::tuples::tuple(decay(a),</span> <span class="pre">b)</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">std::tie(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></td>
<td><code class="docutils literal"><span class="pre">annex::tuples::tuple(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">std::forward_as_tuple(a,</span> <span class="pre">std::move(b))</span></code></td>
<td><code class="docutils literal"><span class="pre">annex::tuples::tuple(a,</span> <span class="pre">std::move(b))</span></code> <a class="footnote-reference" href="#tuple-note" id="id4">[1]</a></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tuple-note" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td><code class="docutils literal"><span class="pre">std::forward_as_tuple(0)</span></code> and <code class="docutils literal"><span class="pre">annex::tuples::tuple(0)</span></code> differ in that the former creates an
<code class="docutils literal"><span class="pre">std::tuple&lt;int&amp;&amp;&gt;</span></code>, the latter an <code class="docutils literal"><span class="pre">std::tuple&lt;int&gt;</span></code>.</td></tr>
</tbody>
</table>
<p>When the circumstances call for it a traditional, additional <code class="docutils literal"><span class="pre">make_*</span></code> factory is sometimes provided as well.</p>
</div>
<div class="section" id="function">
<span id="id5"></span><h2>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h2>
<p>The annex series of libraries attempts to avoid namespace-scope functions and function templates, favouring instead
namespace-scope constant function objects or variable templates. That is, something such as <code class="docutils literal"><span class="pre">annex::decay(0)</span></code> calls a
particular <code class="docutils literal"><span class="pre">operator()</span></code> overload on a constant named <code class="docutils literal"><span class="pre">decay</span></code>. The motivation behind this is as follows:</p>
<ul>
<li><p class="first">to avoid unwanted and uncontrolled use of Argument-Dependent Lookup</p>
</li>
<li><p class="first">to encourage and facilitate higher-order manipulation; e.g. <code class="docutils literal"><span class="pre">auto&amp;</span> <span class="pre">dc</span> <span class="pre">=</span> <span class="pre">annex::decay;</span></code> is an easy way to alias a
<a class="reference internal" href="#function"><span class="std std-ref">Function</span></a>. Perhaps more importantly the referred <code class="docutils literal"><span class="pre">decay</span></code> object can be passed to another <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a> using
this very same mechanism:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">decay</span></code> were a function template, something such as the following would have to be used as a verbose workaround:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">function_object</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// explicitly qualify to avoid unwanted ADL</span>
    <span class="k">return</span> <span class="n">annex</span><span class="o">::</span><span class="n">decay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">function_object</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>Transforming the function template into a function object so that it can be passed as an argument is pure boilerplate.
In a sense the annex libraries take this precaution ahead of time for convenience to the user.</p>
</li>
</ul>
<p>Eric Niebler elaborates on the benefits of function-like objects in his post <a class="reference external" href="http://ericniebler.com/2014/10/21/customization-point-design-in-c11-and-beyond/">Customization Point Design in C++11 and
Beyond</a>, especially as it relates to ADL.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">annex functions are not customization points and do not perform ADL on behalf of the user unless otherwise
specified.</p>
</div>
<p>For conciseness, and because their nature as objects is mostly an implementation detail, function-like objects are still
referred to as <em>functions</em>. Additionally, functions are consistently defined as follows throughout annex libraries
(e.g. for an assumed <code class="docutils literal"><span class="pre">foo</span></code> function):</p>
<ul>
<li><p class="first">the constant lives in its relevant annex namespace or subnamespace, e.g. <code class="docutils literal"><span class="pre">annex::tuples::foo</span></code></p>
</li>
<li><p class="first">it has type <code class="docutils literal"><span class="pre">annex::tuples::functors::foo</span> <span class="pre">const&amp;</span></code></p>
</li>
<li><p class="first">there is an associated <code class="docutils literal"><span class="pre">annex::tuples::result_of::foo&lt;X,</span> <span class="pre">Y,</span> <span class="pre">Z&gt;</span></code> alias which is short for:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">decltype</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">some functions are parametrised over types and constants, in which case they are constant templates e.g.
<code class="docutils literal"><span class="pre">annex::tuples::foo&lt;int,</span> <span class="pre">0&gt;</span></code> of type <code class="docutils literal"><span class="pre">annex::tuples::functors::foo&lt;int,</span> <span class="pre">0&gt;</span> <span class="pre">const&amp;</span></code> and with alias
<code class="docutils literal"><span class="pre">annex::tuples::result_of::foo&lt;int,</span> <span class="pre">0,</span> <span class="pre">X,</span> <span class="pre">Y,</span> <span class="pre">Z&gt;</span></code> short for:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">decltype</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">)</span>
</pre></div>
</div>
<p>Due to limitations in the language, constant templates that accept a variadic number of arguments cannot have a
<code class="docutils literal"><span class="pre">result_of</span></code> alias:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">reorder_to</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">);</span>
<span class="c1">// not possible:</span>
<span class="c1">// using res_t = annex::tuples::result_of::reorder_to&lt;int, char, decltype(tup)&amp;&gt;;</span>
</pre></div>
</div>
</li>
<li><p class="first">functions have additional functionality, e.g. they can be partially applied:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">foo</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">partial</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>A call to <code class="docutils literal"><span class="pre">partial</span></code> produces a new function-like object, which can in turn be subject to a call to <code class="docutils literal"><span class="pre">partial</span></code>
again, or be invoked with final arguments. Many functions take <code class="docutils literal"><span class="pre">partial</span></code> into account when it comes to parameter
order to help with higher-order usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">annex</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">succ</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">arg</span><span class="p">;</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">map</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">succ</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="simple-model">
<span id="id6"></span><h2>Simple model<a class="headerlink" href="#simple-model" title="Permalink to this headline">¶</a></h2>
<p>A <em>simple model</em> of a concept is intended to be the least surprising possible type which fulfils this concept, given
some parameters. In particular, simple models associated with a factory <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a> behave according to the
following (e.g. assuming an associated <code class="docutils literal"><span class="pre">annex::ns::foo</span></code> factory):</p>
<ul>
<li><p class="first">the name of the class or class template that will model the concept follows closely that of the <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a>, e.g.
<code class="docutils literal"><span class="pre">annex::ns::foo_type</span></code></p>
</li>
<li><p class="first">a valid call <code class="docutils literal"><span class="pre">annex::ns::foo(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> produces an <code class="docutils literal"><span class="pre">annex::ns::foo_type&lt;A,</span> <span class="pre">B,</span> <span class="pre">C&gt;</span></code> result, where <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code>, and
<code class="docutils literal"><span class="pre">C</span></code> are types related to <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, and <code class="docutils literal"><span class="pre">c</span></code> respectively (e.g. a <a class="reference internal" href="#forward-storing"><span class="std std-ref">forward storing</span></a>
<a class="reference internal" href="#function"><span class="std std-ref">Function</span></a> called as <code class="docutils literal"><span class="pre">annex::ns::foo(i,</span> <span class="pre">std::move(j),</span> <span class="pre">0)</span></code> yields an <code class="docutils literal"><span class="pre">annex::ns::foo_type&lt;int&amp;,</span> <span class="pre">int,</span> <span class="pre">int&gt;</span></code>
assuming all <code class="docutils literal"><span class="pre">int</span></code> arguments); while <code class="docutils literal"><span class="pre">annex::ns::foo&lt;X,</span> <span class="pre">Y,</span> <span class="pre">Z&gt;(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> would produce an <code class="docutils literal"><span class="pre">annex::ns::foo_type&lt;X,</span>
<span class="pre">Y,</span> <span class="pre">Z,</span> <span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C&gt;</span></code> result</p>
</li>
<li><p class="first">some or all of the parameters used to construct the simple model may be available as public data members:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">range</span> <span class="o">=</span> <span class="n">annex</span><span class="o">::</span><span class="n">range</span><span class="p">;</span>
<span class="c1">// decltype( res ) is intended as the least surprising model of a range of ints from 0 to 6 exclusive</span>
<span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">range</span><span class="o">::</span><span class="n">interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">// names of data members documented by interval</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">res</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">from</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">res</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">to</span>   <span class="o">==</span> <span class="mi">6</span> <span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The data members are made public so that the values used to construct the simple model can be retrieved, which
usually takes place <strong>after</strong> normal usage. Hence the members are able to be accessed mutably so as to allow
moves.</p>
<p class="last">However those data members are used by the type in order to fulfil the concept operations and are not merely
copies of the parameters used at construction&#8211;the user should store its own if that&#8217;s what they need. This means
that modifying those members before or during use of the associated concept operations should be done at own risk,
and considered extremely brittle.</p>
</div>
</li>
</ul>
<p>Because a simple model is closely associated to its factory <a class="reference internal" href="#function"><span class="std std-ref">Function</span></a>, its precise capabilities are normally
described in the function documentation.</p>
</div>
<div class="section" id="concepts">
<h2>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="base-convenience-concepts">
<h3>Base &amp; convenience concepts<a class="headerlink" href="#base-convenience-concepts" title="Permalink to this headline">¶</a></h3>
<dl class="concept">
<dt id="_CPPv2I0EN5annex4TypeE">
template&lt;typename <code class="descname">X</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Type</code><a class="headerlink" href="#_CPPv2I0EN5annex4TypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The trivial concept satisfied by any type. It&#8217;s used as a shortcut for template introductions:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="p">{</span><span class="n">Item</span><span class="p">}</span> <span class="n">Item</span><span class="o">*</span> <span class="n">addressof</span><span class="p">(</span><span class="n">Item</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2IDpEN5annex5TypesE">
template&lt;typename ...<code class="descname">Xs</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Types</code> = (... &amp;&amp; Type&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEN5annex5TypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A variadic variant of <a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type"><code class="xref cpp cpp-any docutils literal"><span class="pre">Type</span></code></a>, for introducing multiple parameters and/or a pack:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Types</span><span class="p">{</span><span class="n">First</span><span class="p">,</span> <span class="p">...</span> <span class="n">Rest</span><span class="p">}</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">First</span><span class="o">&amp;&amp;</span> <span class="n">first</span><span class="p">,</span> <span class="n">Rest</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX4TypeI1XEEN5annex8VariableE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">X</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Variable</code><a class="headerlink" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The basis of <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a>. It is the minimal constraint for the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Variable</span><span class="p">{</span><span class="n">Var</span><span class="p">}</span> <span class="k">struct</span> <span class="n">generic_data</span> <span class="p">{</span> <span class="n">Var</span> <span class="n">member</span><span class="p">;</span> <span class="p">};</span>

<span class="n">Variable</span><span class="p">{</span><span class="n">Var</span><span class="p">}</span> <span class="kt">void</span> <span class="n">generic_function</span><span class="p">(</span><span class="n">generic_data</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span> <span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE">
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Variables</code> = (... &amp;&amp; Variable&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A variadic variant of <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a>, for introducing multiple parameters and/or a pack.</p>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2IDpEX5TypesIsp4PackEEN5annex12NonEmptyPackE">
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Pack</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">NonEmptyPack</code> = sizeof...(Pack) != 0<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp4PackEEN5annex12NonEmptyPackE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A pseudo-concept for constraining variadic templates that are not valid for empty packs.</p>
</dd></dl>

<p>Sister concepts are usually presented together, alongside variadic variants when they make sense:</p>
<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex7ExampleE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Example</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex7ExampleE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX4TypeI1XEEN5annex11ExampleTypeE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">X</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ExampleType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI1XEEN5annex11ExampleTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex8ExamplesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Examples</code> = (... &amp;&amp; Example&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex8ExamplesE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex12ExampleTypesE">
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ExampleTypes</code> = (... &amp;&amp; ExampleType&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex12ExampleTypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A dummy concept to showcase the documentation.</p>
</dd></dl>

</div>
<div class="section" id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="Permalink to this headline">¶</a></h3>
<p>These concepts are nearly equivalent to the corresponding trait (e.g. <code class="xref cpp cpp-any docutils literal"><span class="pre">std::is_constructible_v</span></code> and so on), but in
<a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a> form:</p>
<dl class="concept">
<dt id="_CPPv2I_8VariableDpEN5annex13ConstructibleE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename ...<code class="descname">Inits</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Constructible</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex13ConstructibleE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8Variable0EN5annex10AssignableE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename <code class="descname">Init</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Assignable</code><a class="headerlink" href="#_CPPv2I_8Variable0EN5annex10AssignableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex17MoveConstructibleE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">MoveConstructible</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex17MoveConstructibleE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex18MoveConstructiblesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">MoveConstructibles</code> = (... &amp;&amp; MoveConstructible&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex18MoveConstructiblesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex14MoveAssignableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">MoveAssignable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex14MoveAssignableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex17CopyConstructibleE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">CopyConstructible</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex17CopyConstructibleE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex18CopyConstructiblesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">CopyConstructibles</code> = (... &amp;&amp; CopyConstructible&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex18CopyConstructiblesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex14CopyAssignableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">CopyAssignable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex14CopyAssignableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>As well as some shortcuts:</p>
<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex7MovableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Movable</code> = MoveConstructible&lt;Var&gt; &amp;&amp; MoveAssignable&lt;Var&gt;<a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex7MovableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex8MovablesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Movables</code> = (... &amp;&amp; Movable&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex8MovablesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex8CopyableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Copyable</code> = CopyConstructible&lt;Var&gt; &amp;&amp; CopyAssignable&lt;Var&gt;<a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex8CopyableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex9CopyablesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Copyables</code> = (... &amp;&amp; Copyable&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex9CopyablesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>There are construction concepts that make it easy to constrain factory <a class="reference internal" href="#function"><span class="std std-ref">functions</span></a>:</p>
<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex11ForwardableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Forwardable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex11ForwardableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX4TypeI1XEEN5annex15ForwardableTypeE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">X</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardableType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI1XEEN5annex15ForwardableTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex12ForwardablesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Forwardables</code> = (... &amp;&amp; Forwardable&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex12ForwardablesE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex16ForwardableTypesE">
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardableTypes</code> = (... &amp;&amp; ForwardableType&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex16ForwardableTypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For factories that use <a class="reference internal" href="#forward-storing"><span class="std std-ref">Forward Storing</span></a> for their arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ForwardableType</span><span class="p">{</span><span class="n">Param</span><span class="p">}</span>
<span class="n">foo_type</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="n">Param</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3VarEEN5annex8StorableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Storable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3VarEEN5annex8StorableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX4TypeI3VarEEN5annex12StorableTypeE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Var</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">StorableType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI3VarEEN5annex12StorableTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX9VariablesIsp4VarsEEN5annex9StorablesE">
<a class="reference internal" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex9VariablesE" title="annex::Variables">Variables</a>{...<code class="descname">Vars</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Storables</code> = (... &amp;&amp; Storable&lt;Vars&gt;)<a class="headerlink" href="#_CPPv2IDpEX9VariablesIsp4VarsEEN5annex9StorablesE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2IDpEX5TypesIsp2XsEEN5annex13StorableTypesE">
<a class="reference internal" href="#_CPPv2IDpEN5annex5TypesE" title="annex::Types">Types</a>{...<code class="descname">Xs</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">StorableTypes</code> = (... &amp;&amp; StorableType&lt;Xs&gt;)<a class="headerlink" href="#_CPPv2IDpEX5TypesIsp2XsEEN5annex13StorableTypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For factories that decay their arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">StorableType</span><span class="p">{</span><span class="n">Param</span><span class="p">}</span>
<span class="n">foo_type</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;&gt;</span> <span class="n">make_foo</span><span class="p">(</span><span class="n">Param</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Param</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="iterators">
<h3>Iterators<a class="headerlink" href="#iterators" title="Permalink to this headline">¶</a></h3>
<p>These correspond to the Standard iterator concepts, but in <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a> form:</p>
<dl class="concept">
<dt id="_CPPv2I0EX8VariableI2ItEEN5annex13InputIteratorE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InputIterator</code><a class="headerlink" href="#_CPPv2I0EX8VariableI2ItEEN5annex13InputIteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX4TypeI2ItEEN5annex17InputIteratorTypeE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InputIteratorType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI2ItEEN5annex17InputIteratorTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX13InputIteratorI2ItEEN5annex15ForwardIteratorE">
<a class="reference internal" href="#_CPPv2I0EX8VariableI2ItEEN5annex13InputIteratorE" title="annex::InputIterator">InputIterator</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardIterator</code><a class="headerlink" href="#_CPPv2I0EX13InputIteratorI2ItEEN5annex15ForwardIteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX17InputIteratorTypeI2ItEEN5annex19ForwardIteratorTypeE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI2ItEEN5annex17InputIteratorTypeE" title="annex::InputIteratorType">InputIteratorType</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">ForwardIteratorType</code><a class="headerlink" href="#_CPPv2I0EX17InputIteratorTypeI2ItEEN5annex19ForwardIteratorTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX15ForwardIteratorI2ItEEN5annex21BidirectionalIteratorE">
<a class="reference internal" href="#_CPPv2I0EX13InputIteratorI2ItEEN5annex15ForwardIteratorE" title="annex::ForwardIterator">ForwardIterator</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">BidirectionalIterator</code><a class="headerlink" href="#_CPPv2I0EX15ForwardIteratorI2ItEEN5annex21BidirectionalIteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX19ForwardIteratorTypeI2ItEEN5annex25BidirectionalIteratorTypeE">
<a class="reference internal" href="#_CPPv2I0EX17InputIteratorTypeI2ItEEN5annex19ForwardIteratorTypeE" title="annex::ForwardIteratorType">ForwardIteratorType</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">BidirectionalIteratorType</code><a class="headerlink" href="#_CPPv2I0EX19ForwardIteratorTypeI2ItEEN5annex25BidirectionalIteratorTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX21BidirectionalIteratorI2ItEEN5annex20RandomAccessIteratorE">
<a class="reference internal" href="#_CPPv2I0EX15ForwardIteratorI2ItEEN5annex21BidirectionalIteratorE" title="annex::BidirectionalIterator">BidirectionalIterator</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">RandomAccessIterator</code><a class="headerlink" href="#_CPPv2I0EX21BidirectionalIteratorI2ItEEN5annex20RandomAccessIteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX25BidirectionalIteratorTypeI2ItEEN5annex24RandomAccessIteratorTypeE">
<a class="reference internal" href="#_CPPv2I0EX19ForwardIteratorTypeI2ItEEN5annex25BidirectionalIteratorTypeE" title="annex::BidirectionalIteratorType">BidirectionalIteratorType</a>{<code class="descname">It</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">RandomAccessIteratorType</code><a class="headerlink" href="#_CPPv2I0EX25BidirectionalIteratorTypeI2ItEEN5annex24RandomAccessIteratorTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>As well as the non-standard:</p>
<dl class="concept">
<dt id="_CPPv2I0EX8VariableI4IterEEN5annex8IterableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Iter</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Iterable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI4IterEEN5annex8IterableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0EX4TypeI4IterEEN5annex12IterableTypeE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Iter</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">IterableType</code><a class="headerlink" href="#_CPPv2I0EX4TypeI4IterEEN5annex12IterableTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Iter</span> <span class="n">iter</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A variable which can provide a readable, notional sequence of elements via models of <a class="reference internal" href="#_CPPv2I0EX8VariableI2ItEEN5annex13InputIteratorE" title="annex::InputIterator"><code class="xref cpp cpp-any docutils literal"><span class="pre">InputIterator</span></code></a> provided
through the <code class="xref cpp cpp-any docutils literal"><span class="pre">ops::begin</span></code> and <code class="xref cpp cpp-any docutils literal"><span class="pre">ops::end</span></code> operations:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">ops</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="c1">// use elem</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Requirements:</th><td class="field-body"><code class="xref cpp cpp-any docutils literal"><span class="pre">ops::begin(iter)</span></code>, <code class="xref cpp cpp-any docutils literal"><span class="pre">ops::end(iter)</span></code>: obtain an initial and final <a class="reference internal" href="#_CPPv2I0EX8VariableI2ItEEN5annex13InputIteratorE" title="annex::InputIterator"><code class="xref cpp cpp-any docutils literal"><span class="pre">InputIterator</span></code></a> into
the notional sequence respectively&#8212;both results must have identical types, and <em>last</em> must be reachable from
<em>first</em></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="invocation">
<h3>Invocation<a class="headerlink" href="#invocation" title="Permalink to this headline">¶</a></h3>
<dl class="var">
<dt id="_CPPv2N5annex6invokeE">
<span id="annex::invoke__functors::invokeCR"></span><em class="property">constexpr</em> functors::invoke <em class="property">const</em> &amp;<code class="descclassname"></code><code class="descname">invoke</code><a class="headerlink" href="#_CPPv2N5annex6invokeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="function">
<dt id="_CPPv2I0DpENK5annex6invokeclERR4FuncDpRR4Args">
template&lt;typename <code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">constexpr</em> unspecified <code class="descclassname"></code><code class="descname">operator()</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0DpENK5annex6invokeclERR4FuncDpRR4Args" title="annex::invoke::operator()::Func">Func</a> &amp;&amp;<em>func</em>, <a class="reference internal" href="#_CPPv2I0DpENK5annex6invokeclERR4FuncDpRR4Args" title="annex::invoke::operator()::Args">Args</a>&amp;&amp;... <em>args</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2I0DpENK5annex6invokeclERR4FuncDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke <em>func</em> given arguments <em>args...</em>. This is an implementation of the Standard <em>INVOKE</em> protocol with no
given converted return type.</p>
</dd></dl>

</dd></dl>

<dl class="var">
<dt id="_CPPv2I0EN5annex9invoke_asE">
template&lt;typename <code class="descname">Result</code>&gt;<br /><em class="property">constexpr</em> functors::invoke_as&lt;Result&gt; <em class="property">const</em> &amp;<code class="descclassname"></code><code class="descname">invoke_as</code><a class="headerlink" href="#_CPPv2I0EN5annex9invoke_asE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Template Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><strong>Result</strong> &#8211; Converted return type.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="_CPPv2I0DpENK5annex9invoke_asclERR4FuncDpRR4Args">
template&lt;typename <code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">constexpr</em> Result <code class="descclassname"></code><code class="descname">operator()</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2I0DpENK5annex9invoke_asclERR4FuncDpRR4Args" title="annex::invoke_as::operator()::Func">Func</a> &amp;&amp;<em>func</em>, <a class="reference internal" href="#_CPPv2I0DpENK5annex9invoke_asclERR4FuncDpRR4Args" title="annex::invoke_as::operator()::Args">Args</a>&amp;&amp;... <em>args</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2I0DpENK5annex9invoke_asclERR4FuncDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke <em>func</em> given arguments <em>args...</em> and implicitly convert the result to <code class="xref cpp cpp-any docutils literal"><span class="pre">Result</span></code>. This is an implementation
of the Standard <em>INVOKE</em> protocol with a given converted return type.</p>
<p><code class="xref cpp cpp-any docutils literal"><span class="pre">Result</span></code> may also be <code class="docutils literal"><span class="pre">void</span></code> or <code class="xref cpp cpp-any docutils literal"><span class="pre">unit_type</span></code>, in which case the result is discarded.</p>
</dd></dl>

</dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8VariableDpEN5annex13OnceInvokableE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">OnceInvokable</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex13OnceInvokableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0DpEN5annex17OnceInvokableTypeE">
template&lt;typename <code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">OnceInvokableType</code><a class="headerlink" href="#_CPPv2I0DpEN5annex17OnceInvokableTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Func</span> <span class="n">func</span><span class="p">;</span>
<span class="n">Args</span> <span class="n">args</span><span class="p">...;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A variable that can be once-invoked given some arguments. Note that the <code class="docutils literal"><span class="pre">Args</span></code> are not constrained to be models of
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="c1">// N.B. ------^^^^^^^^^^^^^^^^^^^^^^^^</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Forwarding gives an opportunity to <em>func</em> to optimise the invocation, but it means that <em>func</em> should be treated
with caution if the invocation was final in the case that <em>func</em> was effectively moved from:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Func</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">example</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">Params</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">requires</span>
        <span class="c1">// first invocations constraint</span>
        <span class="n">OnceInvokableType</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Params</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span><span class="o">&gt;</span>

        <span class="c1">// possibly final invocation constraint</span>
        <span class="n">OnceInvokableType</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="n">Params</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// first invocation</span>
    <span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">params</span><span class="p">...);</span>
    <span class="c1">// second invocation possible: func has not been forwarded</span>
    <span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">params</span><span class="p">...);</span>

    <span class="c1">// possibly final invocation</span>
    <span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">params</span><span class="p">...);</span>

    <span class="c1">// invoking again would be ill-advised: func may have been</span>
    <span class="c1">// moved-from or otherwise pilfered</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable</span></code></a>, <a class="reference internal" href="#_CPPv2I0DpEN5annex13InvokableTypeE" title="annex::InvokableType"><code class="xref cpp cpp-any docutils literal"><span class="pre">InvokableType</span></code></a></dt>
<dd>Non-forwarding variants that should be preferred if <em>func</em> is not being forwarded and will be called
repeatedly.</dd>
</dl>
</div>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8VariableDpEN5annex9InvokableE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Invokable</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0DpEN5annex13InvokableTypeE">
template&lt;typename <code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InvokableType</code><a class="headerlink" href="#_CPPv2I0DpEN5annex13InvokableTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Func</span> <span class="n">func</span><span class="p">;</span>
<span class="n">Args</span> <span class="n">args</span><span class="p">...;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A variable that can be invoked repeatedly given some arguments. Note that the <code class="docutils literal"><span class="pre">Args</span></code> are not constrained to be
models of <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Variable</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex13OnceInvokableE" title="annex::OnceInvokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">OnceInvokable</span></code></a>, <a class="reference internal" href="#_CPPv2I0DpEN5annex17OnceInvokableTypeE" title="annex::OnceInvokableType"><code class="xref cpp cpp-any docutils literal"><span class="pre">OnceInvokableType</span></code></a></dt>
<dd>Forwarding variants, applicable for one-shot invocations.</dd>
</dl>
</div>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I0_8VariableDpEN5annex15OnceInvokableAsE">
template&lt;typename <code class="descname">Result</code>, <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">OnceInvokableAs</code><a class="headerlink" href="#_CPPv2I0_8VariableDpEN5annex15OnceInvokableAsE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I00DpEN5annex19OnceInvokableAsTypeE">
template&lt;typename <code class="descname">Result</code>, typename <code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">OnceInvokableAsType</code><a class="headerlink" href="#_CPPv2I00DpEN5annex19OnceInvokableAsTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0_8VariableDpEN5annex11InvokableAsE">
template&lt;typename <code class="descname">Result</code>, <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InvokableAs</code><a class="headerlink" href="#_CPPv2I0_8VariableDpEN5annex11InvokableAsE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I00DpEN5annex15InvokableAsTypeE">
template&lt;typename <code class="descname">Result</code>, typename <code class="descname">Func</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">InvokableAsType</code><a class="headerlink" href="#_CPPv2I00DpEN5annex15InvokableAsTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Variants of <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex13OnceInvokableE" title="annex::OnceInvokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">OnceInvokable</span></code></a> and <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable</span></code></a> except specified in terms of <a class="reference internal" href="#_CPPv2I0EN5annex9invoke_asE" title="annex::invoke_as"><code class="xref cpp cpp-any docutils literal"><span class="pre">annex::invoke_as&lt;Result&gt;</span></code></a>
instead of <a class="reference internal" href="#_CPPv2N5annex6invokeE" title="annex::invoke"><code class="xref cpp cpp-any docutils literal"><span class="pre">annex::invoke</span></code></a>.</p>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8VariableDpEN5annex9PredicateE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Pred</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Predicate</code><a class="headerlink" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I0DpEN5annex13PredicateTypeE">
template&lt;typename <code class="descname">Pred</code>, typename ...<code class="descname">Args</code>&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">PredicateType</code><a class="headerlink" href="#_CPPv2I0DpEN5annex13PredicateTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Pred</span> <span class="n">pred</span><span class="p">;</span>
<span class="n">Args</span> <span class="n">args</span><span class="p">...;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A refinement of <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9InvokableE" title="annex::Invokable"><code class="xref cpp cpp-any docutils literal"><span class="pre">Invokable&lt;Pred,</span> <span class="pre">Args...&gt;</span></code></a>, which further requires that the invocation
result must be a model of <code class="xref cpp cpp-any docutils literal"><span class="pre">ContextualBool</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="p">{</span> <span class="n">annex</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">};</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8Variable00EN5annex11EquivalenceE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Pred</code>, typename <code class="descname">Lhs</code>, typename <code class="descname">Rhs</code> = Lhs&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Equivalence</code><a class="headerlink" href="#_CPPv2I_8Variable00EN5annex11EquivalenceE" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv2I000EN5annex15EquivalenceTypeE">
template&lt;typename <code class="descname">Pred</code>, typename <code class="descname">Lhs</code>, typename <code class="descname">Rhs</code> = Lhs&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">EquivalenceType</code><a class="headerlink" href="#_CPPv2I000EN5annex15EquivalenceTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Pred</span> <span class="n">pred</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A refinement of <a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate</span></code></a> (see additional requirements) where <em>pred</em> induces an equivalence relation, meaning it
respects the axioms of reflexivity, symmetry, and transitivity when called on arguments with types <code class="xref cpp cpp-any docutils literal"><span class="pre">Lhs</span></code> or <code class="xref cpp cpp-any docutils literal"><span class="pre">Rhs</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Additional requirements:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Pred,</span> <span class="pre">Lhs,</span> <span class="pre">Lhs&gt;</span></code></a></p>
<p><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Pred,</span> <span class="pre">Rhs,</span> <span class="pre">Rhs&gt;</span></code></a></p>
<p><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Pred,</span> <span class="pre">Lhs,</span> <span class="pre">Rhs&gt;</span></code></a></p>
<p class="last"><a class="reference internal" href="#_CPPv2I_8VariableDpEN5annex9PredicateE" title="annex::Predicate"><code class="xref cpp cpp-any docutils literal"><span class="pre">Predicate&lt;Pred,</span> <span class="pre">Rhs,</span> <span class="pre">Rhs&gt;</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="various">
<h3>Various<a class="headerlink" href="#various" title="Permalink to this headline">¶</a></h3>
<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3IntEEN5annex8IntegralE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Int</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Integral</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3IntEEN5annex8IntegralE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="xref cpp cpp-any docutils literal"><span class="pre">std::is_integral_v</span></code> in <a class="reference internal" href="#concepts-for-variables"><span class="std std-ref">Concepts for variables</span></a> form.</p>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI3IntEEN5annex14SignedIntegralE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Int</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">SignedIntegral</code><a class="headerlink" href="#_CPPv2I0EX8VariableI3IntEEN5annex14SignedIntegralE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A refinement of <a class="reference internal" href="#_CPPv2I0EX8VariableI3IntEEN5annex8IntegralE" title="annex::Integral"><code class="xref cpp cpp-any docutils literal"><span class="pre">Integral</span></code></a> for signed integer types.</p>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8Variable_8VariableEN5annex18EqualityComparableE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Lhs</code>, <a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Rhs</code> = Lhs&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">EqualityComparable</code><a class="headerlink" href="#_CPPv2I_8Variable_8VariableEN5annex18EqualityComparableE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Lhs</span> <span class="n">lhs</span><span class="p">;</span> <span class="n">Rhs</span> <span class="n">rhs</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Decidable equality relation between possibly heterogeneous variables. This must induce an equivalence relation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><code class="docutils literal"><span class="pre">lhs</span> <span class="pre">==</span> <span class="pre">rhs</span></code>, <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">!=</span> <span class="pre">rhs</span></code> which must be contextual booleans</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="type">
<dt id="_CPPv2I0EX4TypeI4NullEEN5annex22nullable_dereference_tE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Null</code>}<br /><em class="property">using </em><code class="descclassname"></code><code class="descname">nullable_dereference_t</code><a class="headerlink" href="#_CPPv2I0EX4TypeI4NullEEN5annex22nullable_dereference_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Null</span> <span class="n">nullable</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>The result type of <code class="docutils literal"><span class="pre">*std::forward&lt;Null&gt;(nullable)</span></code></p>
</dd></dl>

<dl class="type">
<dt id="_CPPv2I0EX4TypeI4NullEEN5annex18nullable_element_tE">
<a class="reference internal" href="#_CPPv2I0EN5annex4TypeE" title="annex::Type">Type</a>{<code class="descname">Null</code>}<br /><em class="property">using </em><code class="descclassname"></code><code class="descname">nullable_element_t</code><a class="headerlink" href="#_CPPv2I0EX4TypeI4NullEEN5annex18nullable_element_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The underlying element type of a nullable variable.</p>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I0EX8VariableI4NullEEN5annex8NullableE">
<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a>{<code class="descname">Null</code>}<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">Nullable</code><a class="headerlink" href="#_CPPv2I0EX8VariableI4NullEEN5annex8NullableE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Null</span> <span class="n">nullable</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A possibly null variable which can be tested for, indirected if non-null, and reset to a null state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expressions:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><code class="docutils literal"><span class="pre">nullable</span></code>: must be a contextual <code class="docutils literal"><span class="pre">bool</span></code> for testing the null state; <code class="docutils literal"><span class="pre">true</span></code> indicates a non-null <em>nullable</em></p>
<p><code class="docutils literal"><span class="pre">nullable</span> <span class="pre">=</span> <span class="pre">{}</span></code>: reset the variable to a null state, such that <code class="docutils literal"><span class="pre">!nullable</span></code> holds afterwards</p>
<p><code class="docutils literal"><span class="pre">*std::forward&lt;Null&gt;(nullable)</span></code>: access to the indirected value on the precondition that <em>nullable</em> is non-null</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Associated types:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first last"><a class="reference internal" href="#_CPPv2I0EX4TypeI4NullEEN5annex22nullable_dereference_tE" title="annex::nullable_dereference_t"><code class="xref cpp cpp-any docutils literal"><span class="pre">nullable_dereference_t</span></code></a>, <a class="reference internal" href="#_CPPv2I0EX4TypeI4NullEEN5annex18nullable_element_tE" title="annex::nullable_element_t"><code class="xref cpp cpp-any docutils literal"><span class="pre">nullable_element_t</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="concept">
<dt id="_CPPv2I_8Variable0EN5annex17StreamExtractableE">
template&lt;<a class="reference internal" href="#_CPPv2I0EX4TypeI1XEEN5annex8VariableE" title="annex::Variable">Variable</a> <code class="descclassname"></code><code class="descname">Var</code>, typename <code class="descname">Stream</code> = std::ostream&amp;&gt;<br /><em class="property">concept </em>bool <code class="descclassname"></code><code class="descname">StreamExtractable</code><a class="headerlink" href="#_CPPv2I_8Variable0EN5annex17StreamExtractableE" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notation:</th><td class="field-body"><div class="first last highlight-c++"><div class="highlight"><pre><span></span><span class="n">Var</span> <span class="n">extractable</span><span class="p">;</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>A variable which can be extracted from a stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Associated expression:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><code class="docutils literal"><span class="pre">std::declval&lt;Stream&amp;&gt;()</span> <span class="pre">&gt;&gt;</span> <span class="pre">extractable</span></code>: extract into variable</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="motivation.html">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="concepts.html">Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="operations.html">Operations &amp; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sources.html">Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumers.html">Consumers</a></li>
<li class="toctree-l2"><a class="reference internal" href="transformations.html">Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="compositions.html">Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrangements.html">Arrangements</a></li>
<li class="toctree-l2"><a class="reference internal" href="common.html">Common</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Annex quick reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#concepts-for-variables">Concepts for variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#forward-storing">Forward Storing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function">Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-model">Simple model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concepts">Concepts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#base-convenience-concepts">Base &amp; convenience concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#construction">Construction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterators">Iterators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invocation">Invocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#various">Various</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#how-to-read-the-reference">How to read the reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="open_questions.html">Open questions</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="common.html"
                        title="previous chapter">Common</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="open_questions.html"
                        title="next chapter">Open questions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/annex.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="open_questions.html" title="Open questions"
             >next</a> |</li>
        <li class="right" >
          <a href="common.html" title="Common"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">annex-range 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="reference.html" >Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, mickk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>