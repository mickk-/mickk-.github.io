<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <link rel="stylesheet" href="styles/stylesheet.css" type="text/css" />
  <link rel="stylesheet" href="styles/buttondown.css" type="text/css" />
</head>
<body>
<div id="a-devlog-on-ranges" class="section level1">
<h1>A devlog on ranges</h1>
<div id="wip" class="section level2">
<h2>WIP</h2>
<table>
<caption>A brief comparison of self-contained vs.Â position-based ranges (with non-primitives highlighted)</caption>
<col width="22%" />
<col width="27%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Operate on</th>
<th align="left">Self-contained</th>
<th align="left">Position-based</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">any range</td>
<td align="left"><code>empty()</code></td>
<td align="left"><code class="convenience">empty()</code><br /><code>equals_stop(start())</code> (forward)<br /><code>equals_start(stop())</code> (backward)</td>
</tr>
<tr class="even">
<td align="left">the front</td>
<td align="left"><code>peek_front()</code><br /><code>front()</code><br /><code>pop_front()</code></td>
<td align="left"><code>peek_at(start())</code><br /><code>at(start())</code><br /><code>incr(start())</code><br /><code class="convenience">next(pos)</code></td>
</tr>
<tr class="odd">
<td align="left">the back</td>
<td align="left"><code>peek_back()</code><br /><code>back()</code><br /><code>pop_back()</code></td>
<td align="left"><code>peek_at(prev(stop()))</code><br /><code>at(prev(stop()))</code><br /><code>decr(stop())</code><br /><code class="convenience">prev(pos)</code></td>
</tr>
<tr class="even">
<td align="left">arbitrary pos.</td>
<td align="left"><code>chop_front(n)</code><br /><code>chop_back(n)</code></td>
<td align="left"><code>step(start(), n)</code><br /><code>step(stop(), n)</code><br /><code>step(pos, n)</code></td>
</tr>
</tbody>
</table>
</div>
<div id="zip-range-pseudo-code" class="section level2">
<h2>Zip range pseudo-code</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span>... Ranges&gt;
<span class="kw">struct</span> zip_range {
    <span class="co">/*</span>
<span class="co">     * Invariant required: the ranges must be trimmed at the end if double-ended,</span>
<span class="co">     * i.e. no ragged ends. E.g.:</span>
<span class="co">     *</span>
<span class="co">     * 1: o o o o [o]</span>
<span class="co">     * 2: o o o o [o] x</span>
<span class="co">     * 3: o o o o [o] x x x</span>
<span class="co">     * 4: o o o o [o]</span>
<span class="co">     *             l</span>
<span class="co">     * where &#39;o&#39; is an element, and &#39;x&#39; a superfluous element that must be discarded</span>
<span class="co">     * so that the l column of elements [o] correctly reflect `prev(stop())` for a</span>
<span class="co">     * double-ended zip range.</span>
<span class="co">     */</span>

    std::tuple&lt;Ranges...&gt; zipped_ranges;

    <span class="co">// SFINAE omitted</span>

    <span class="kw">decltype</span>(<span class="dt">auto</span>) start() { <span class="kw">return</span> tuples::transform(zipped_ranges, functors::start {}); }
    <span class="kw">decltype</span>(<span class="dt">auto</span>) stop()  { <span class="kw">return</span> tuples::transform(zipped_ranges, functors::stop {}); }

    <span class="co">/*</span>
<span class="co">     * The suck starts here.</span>
<span class="co">     *</span>
<span class="co">     * How much of {equal_pos, equals_start, equals_stop} should be implemented?</span>
<span class="co">     * Additionally, those implementations are only correct for (trimmed) double-ended</span>
<span class="co">     * ranges. On the other hand, forward-only ranges can implement an efficient</span>
<span class="co">     * `equals_stop` with `functors::logical_or`.</span>
<span class="co">     *</span>
<span class="co">     * Tentative answer: non-overlapping overload set of</span>
<span class="co">     *   - equals_stop + logical_or for forward-only</span>
<span class="co">     *   - equal_pos + logical_and for double-ended or better</span>
<span class="co">     */</span>

    <span class="dt">bool</span> equal_pos(position <span class="dt">const</span>&amp; xs, position <span class="dt">const</span>&amp; ys)
    { <span class="kw">return</span> tuples::fold1(functors::logical_and {}
                           , tuples::zip_with(zipped_ranges
                                             , xs
                                             , ys
                                             , [](<span class="dt">auto</span>&amp; r, <span class="dt">auto</span> <span class="dt">const</span>&amp; x, <span class="dt">auto</span> <span class="dt">const</span>&amp; y)
                                             { <span class="kw">return</span> r.equal_pos(x, y); } ) ); }

    <span class="dt">bool</span> equals_stop(position <span class="dt">const</span>&amp; pos)
    { <span class="kw">return</span> tuples::fold1(functors::logical_and {}
                           , tuples::zip_with(zipped_ranges
                                              , position
                                              , [](<span class="dt">auto</span>&amp; r, <span class="dt">auto</span> <span class="dt">const</span>&amp; p)
                                              { <span class="kw">return</span> r.equals_stop(p); } ) ); }

    <span class="dt">bool</span> equals_start(position <span class="dt">const</span>&amp; pos)
    { <span class="kw">return</span> tuples::fold1(functors::logical_and {}
                           , tuples::zip_with(zipped_ranges
                                              , position
                                              , [](<span class="dt">auto</span>&amp; r, <span class="dt">auto</span> <span class="dt">const</span>&amp; p)
                                              { <span class="kw">return</span> r.equals_start(p); } ) ); }

    <span class="kw">decltype</span>(<span class="dt">auto</span>) peek_at(position <span class="dt">const</span>&amp; pos) <span class="dt">const</span>
    { <span class="kw">return</span> tuples::transform(zipped_ranges, functors::peek_at {}); }

    <span class="kw">decltype</span>(<span class="dt">auto</span>) at(position <span class="dt">const</span>&amp; pos) <span class="dt">const</span>
    { <span class="kw">return</span> tuples::transform(zipped_ranges, functors::at {}); }

    <span class="dt">void</span> incr(position&amp; pos)
    { tuples::zip_with(zipped_ranges, pos, [](<span class="dt">auto</span>&amp; r, <span class="dt">auto</span>&amp; p) { r.incr(p); }); }

    <span class="dt">void</span> decr(position&amp; pos)
    { tuples::zip_with(zipped_ranges, pos, [](<span class="dt">auto</span>&amp; r, <span class="dt">auto</span>&amp; p) { r.decr(p); }); }

    <span class="dt">void</span> step(position&amp; pos, offset <span class="dt">const</span> n)
    { tuples::zip_with(zipped_ranges, pos, [&amp;n](<span class="dt">auto</span>&amp; r, <span class="dt">auto</span>&amp; p) { r.step(p, n); }); }
};</code></pre>
</div>
<div id="fliter-range-pseudo-code" class="section level2">
<h2>Fliter range pseudo-code</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> Tag, <span class="kw">typename</span> Position&gt;
<span class="kw">struct</span> tagged_position: Position {
    <span class="kw">using</span> Position::Position;
};

<span class="kw">template</span>&lt;<span class="kw">typename</span> Tag, <span class="kw">typename</span> Position&gt;
tagged_position&lt;Tag, std::decay_t&lt;Position&gt;&gt; tag(Position&amp;&amp; position)
{ <span class="kw">return</span> { std::forward&lt;Position&gt;(position) }; }

<span class="kw">template</span>&lt;<span class="kw">typename</span> Predicate, <span class="kw">typename</span> Range&gt;
<span class="kw">struct</span> filter_range {
    Range filtered_range;
    Predicate filtering_predicate;

    <span class="kw">struct</span> tag {};

    <span class="co">// SFINAE omitted</span>

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="kw">decltype</span>(<span class="dt">auto</span>) peek_at(Position <span class="dt">const</span>&amp; position) { <span class="kw">return</span> range::peek_at(filtered_range, position); }

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="kw">decltype</span>(<span class="dt">auto</span>) at(Position <span class="dt">const</span>&amp; position) { <span class="kw">return</span> range::at(filtered_range, position); }

    <span class="kw">decltype</span>(<span class="dt">auto</span>) stop() { <span class="kw">return</span> range::tag&lt;tag&gt;(range::stop(filtered_range)); }

    <span class="co">// Front</span>
    <span class="kw">decltype</span>(<span class="dt">auto</span>) start() { <span class="kw">return</span> range::tag&lt;tag&gt;(range::start(filtered_range)); }

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="dt">bool</span> at_stop(Position <span class="dt">const</span>&amp; position) { <span class="kw">return</span> range::at_stop(filtered_range, position); }

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="dt">void</span> incr(Position&amp; position)
    {
        <span class="kw">do</span> {
            range::incr(filtered_range, position);
        } <span class="kw">while</span>(!range::at_stop(filtered_range, position)
                &amp;&amp; !annex::invoke(filtering_predicate, range::peek_at(filtered_range, position)) );
    }

    <span class="co">// Back</span>

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="dt">bool</span> at_start(Position <span class="dt">const</span>&amp; position) { <span class="kw">return</span> range::at_start(filtered_range, position); }

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="dt">void</span> decr(Position&amp; position)
    {
        <span class="kw">do</span> {
            range::decr(filtered_range, position);
        } <span class="kw">while</span>(!range::at_start(filtered_range, position)
                &amp;&amp; !annex::invoke(filtering_predicate, range::peek_at(filtered_range, position)) );
    }

    <span class="co">// Bidi</span>
    <span class="kw">template</span>&lt;<span class="kw">typename</span> Position&gt;
    <span class="dt">bool</span> equal_pos(Position <span class="dt">const</span>&amp; x, Position <span class="dt">const</span>&amp; y)
    { <span class="kw">return</span> range::equal_pos(filtered_range, x, y); }
};</code></pre>
</div>
<div id="flatten-range-pseudo-code" class="section level2">
<h2>Flatten range pseudo-code</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> Range&gt;
<span class="kw">struct</span> flatten_range {
    Range flattened_range;

    <span class="co">// SFINAE omitted</span>

<span class="kw">private</span>:
    <span class="kw">using</span> current_type = iter_t&lt;element_t&lt;flattened_range&gt;&amp;&gt;;

    <span class="co">// Looks like we&#39;re still using caching</span>
    cache&lt;Range, current_type&gt; current;

<span class="kw">public</span>:
    <span class="kw">decltype</span>(<span class="dt">auto</span>) start()
    { <span class="kw">return</span> current.front()-&gt;start(); }

    <span class="kw">decltype</span>(<span class="dt">auto</span>) stop()
    { <span class="kw">return</span> current.back() ? current.back()-&gt;stop() : current.front()-&gt;stop(); }

    <span class="co">/*</span>
<span class="co">     * Looks like we&#39;re double-ended at most, since there&#39;s no telling to which inner range</span>
<span class="co">     * a position belongs, but it also looks like we need empty() as a primitive and</span>
<span class="co">     * not just a convenience.</span>
<span class="co">     */</span>
    <span class="dt">bool</span> empty() <span class="dt">const</span>
    { <span class="kw">return</span> !current.front() || current.front()-&gt;empty(); }

    <span class="co">/*</span>
<span class="co">     * UHOH! The above was clearly a warning sign, as it turns out we cannot define anything else:</span>
<span class="co">     * when we receive a position, we really need to know to which inner range (or end) it belongs to</span>
<span class="co">     * (e.g. for the `front() ==&gt; at(start())` translation). So we&#39;re back to self-contained ranges.</span>
<span class="co">     * Relatedly it may be that &#39;double-ended + saveable == bidi&#39; may not be that straightforward either.</span>
<span class="co">     */</span>
};</code></pre>
</div>
</div>
</body>
</html>
